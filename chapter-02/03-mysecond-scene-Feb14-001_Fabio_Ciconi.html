<!DOCTYPE html>

<html>

<head>
	<title>Second Scene of fn ln - Fog, FogExp2 ...</title>
	<script src="../../../libs/three.js"></script>
	<script src="../../../libs/stats.js"></script>
	<script src="../../../libs/dat.GUI.js"></script>

	<style>
		body {
			margin: 0;
			overflow: hidden;
		}
	</style>
</head>

<body>

	<!-- Div which will hold the Output -->
	<div id="WebGL-output">
	</div>

	<div id="stats-output">
	</div>



	<!-- Javascript code that runs our Three.js examples -->
	<script type="text/javascript">
		// once everything is loaded, we run our Three.js stuff.
		var pointLight;
		function init() {
			var renderer, scene, camera, spotLight, stats;
			var controls;
			var gui, green_cube;
			var step = 0;
			//Feb.07 - add ambent light
			var ambientLight;
			var pointColor = "#00ff00";
			controls = new function () {
				this.dx = 8;
				this.dy = 8;
				this.dz = 8;
				//exercise together
				this.px = 0;
				this.py = 4;
				this.pz = -8;
				//exercise you
				//do the same for rx,ry, and rz
				this.pointColor = pointColor;
				this.pointIntensity = 1;
				this.pointDistance = 100;
				//Feb.12 - Add Fog controls
				this.fogColor = "#FFFFFF";
				this.fogNear = 25;
				this.fogFar = 100;
				//FogExp2 controls
				this.fog2Color = "#FFFFFF";
				this.fog2Density = 0.01;
				//scene.overrideMaterial controls
				this.overrideMaterialColor = "#FFFFFF";
				this.overrideMaterialWireFrame = true;
				this.overrideMaterialWireFrameLW = 1;




			}

			{//set up dat.GUI
				gui = new dat.GUI();
				gui.add(controls, 'dx', 0, 10); //dx has range type 
				gui.add(controls, 'dy', 0, 30); //dx has range type 
				gui.add(controls, 'dz', 0, 10); //dx has range type 
				gui.add(controls, 'px', -20, 20); //dx has range type 
				gui.add(controls, 'py', 0, 100); //dx has range type 
				gui.add(controls, 'pz', -20, 20); //dx has range type 
				//Feb.07 - dealing with colors
				gui.addColor(controls, 'pointColor').onChange((c) => { pointLight.color = new THREE.Color(c); });
				gui.add(controls, 'pointIntensity', 0, 1).onChange((intensity) => { pointLight.intensity = intensity; });
				gui.add(controls, 'pointDistance', 0, 200).onChange((distance) => { pointLight.distance = distance; });

				//Feb.12 - using addFolder
				var folderFog = gui.addFolder("Fog Controls");
				folderFog.addColor(controls, 'fogColor').onChange((c) => { scene.fog.color = new THREE.Color(c); }); // use color directly
				folderFog.add(controls, 'fogNear', 0, 50).onChange((near) => { scene.fog.near = near; }); // use near directly
				folderFog.add(controls, 'fogFar', 50, 200).onChange((far) => { scene.fog.far = far; }); // use near directly

				var folderFog2 = gui.addFolder("FogExp2 Controls");
				folderFog2.addColor(controls, 'fog2Color').onChange((c) => { scene.fog.color = new THREE.Color(c); }); // use color directly
				folderFog2.add(controls, 'fog2Density', 0, 0.03).onChange((density) => { scene.fog.density = density; }); // use near directly

				var folderOM = gui.addFolder("Override Material Controls");
				folderOM.addColor(controls, 'overrideMaterialColor').onChange((c) => { scene.overrideMaterial.color = new THREE.Color(c); }); // use color directly
				folderOM.add(controls, 'overrideMaterialWireFrame', [false, true]).onChange((wf) => {
					if (wf == "false")
						scene.overrideMaterial.wireframe = false;
					else {
						scene.overrideMaterial.wireframe = true;
						scene.overrideMaterial.wireframeLinewidth = controls.overrideMaterialWireFrameLW;
					}
				}); // use near directly
				folderOM.add(controls, 'overrideMaterialWireFrameLW', 1, 5).onChange((wflw) => { scene.overrideMaterial.wireframeLinewidth = wflw; }); // use near directly


			}
			{//set up renderer	// create a render and set the size
				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor();
				renderer.setClearColor(new THREE.Color(0xEEEEEE));
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.shadowMapEnabled = true;
			}
			{//init Stats, create scene+camera, add axes
				//stats
				stats = initStats();
				//scene
				scene = new THREE.Scene();
				//camera
				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

				//Create object and add them in the scene  (create the world)
				var axes = new THREE.AxisHelper(20);
				scene.add(axes);
			}
			{//add spheres
				for (var i = 0; i < 10; i++) {
					var px = -10 + Math.random() * 20;
					var pz = -10 + Math.random() * 20;
					var py = Math.random() * 5;

					var sx = .1 + Math.random() * 3.9;
					var sz = .1 + Math.random() * 3.9;

					var sphere = createSphere(1, 20, 20, 0x0000FF, false, px, py, pz, 0, 0, 0, sx, 1, sz);
					//scene.add(sphere);

				}
			}
			{//add cubes
				for (var i = 0; i < 10; i++) {
					var dx = Math.random() * 1.55;
					var dz = Math.random() * 1.55;
					var dy = Math.random() * 10.5;

					var px = -10 + Math.random() * 20;
					var pz = -10 + Math.random() * 20;
					var py = dy / 2;

					var cube = createCubeMLM(dx, dy, dz, 0xFF0000, false, px, py, pz);
					cube.castShadow = true;
					cube.receiveShadow = true;

					scene.add(cube);
				}
			}
			{//add a plane
				//create a plane
				var planeGeometry = new THREE.PlaneGeometry(20, 40, 2, 2);
				var planeMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
				var plane = new THREE.Mesh(planeGeometry, planeMaterial);
				plane.receiveShadow = true;
				plane.rotation.x = -Deg2Rad(90);
				plane.position.z = +10;
				scene.add(plane);
			}
			{//add a spotLight
				//create a light
				//spotLight
				spotLight = new THREE.SpotLight(0xffffff);
				spotLight.position.set(0, 30, 25);
				spotLight.castShadow = true;
				scene.add(spotLight);
			}
			{//add a ambientLight
				//create a light
				//ambientLight
				ambientLight = new THREE.AmbientLight(0x7b8210);
				//scene.add(ambientLight);
			}
			{//add a pointLight
				//create a light
				pointLight = new THREE.PointLight(pointColor);
				pointLight.distance = 10; // 
				//setting position using THREE.Vector3 object/class
				//pointLight.position.set(new THREE.Vector3(3,5,3));
				pointLight.position.x = 3;
				pointLight.position.y = 5;
				pointLight.position.z = 3;
				//pointLight.castShadow=true;
				scene.add(pointLight);
			}
			{//add a green cube
				//function createCubeMLM(dx,dy,dz,col,wf,px,py,pz,rx,ry,rz,sx,sy,sz)
				green_cube = createCubeMLM(controls.dx, controls.dy, controls.dz, 0x00FF00, false,
					controls.px, controls.py, controls.pz);
				green_cube.castShadow = true;
				scene.add(green_cube);
			}
			// add the output of the renderer to the html element
			document.getElementById("WebGL-output").appendChild(renderer.domElement);
			{
				//position camera and scene
				scene.rotation.y = -Deg2Rad(90);
				scene.position.z -= 10;
				// position and point the camera to the center of the scene
				camera.position.x = -30;
				camera.position.y = 40;
				camera.position.z = 30;
				camera.lookAt(scene.position);
			}

			{//add a custom geometry( a trinagular face)
				var vertices = [];
				var faces = [];
				vertices.push(new THREE.Vector3(0, 0, 0)); //V_0
				vertices.push(new THREE.Vector3(1, 0, 0)); //V_1
				vertices.push(new THREE.Vector3(0, 0, 1));  //V_2
				//create faces array
				faces.push(new THREE.Face3(1, 0, 2));

				//create Geometry

				var triangleGeo = new THREE.Geometry();
				triangleGeo.vertices = vertices;
				triangleGeo.faces = faces;
				triangleGeo.computeFaceNormals();

				var mat = new THREE.MeshLambertMaterial({ color: 0xff0000 });
				var triangle = new THREE.Mesh(triangleGeo, mat);
				triangle.scale.set(9, 1, 9);
				scene.add(triangle);
			}
			
			{//Feb 14 - Exercise - Add a custom geometry(a tetrahedron)

				var vertices2 = [];
				var faces2 = [];
				vertices2.push(new THREE.Vector3(0, 0, 0)); //V_0
				vertices2.push(new THREE.Vector3(1, 0, 0)); //V_1
				vertices2.push(new THREE.Vector3(0, 0, 1));  //V_2
				//create faces array
				faces2.push(new THREE.Face3(1, 0, 2));//F_0
		

				//create Geometry
				var tetrahedronGeo = new THREE.Geometry();
				tetrahedronGeo.vertices = vertices;
				tetrahedronGeo.faces = faces;
				tetrahedronGeo.computeFaceNormals();

				var tetrahedronMat = new THREE.MeshLambertMaterial({ color: 0xff0000 });
				var tetrahedron = new THREE.Mesh(triangleGeo, tetrahedronMat);
				tetrahedron.position=new Vector3(10,0,-10);
				tetrahedron.scale.set(5, 5, 5);
				scene.add(tetrahedron);
			
			}
			{//Feb.12 - Fog, FogExp2
				//THREE.Fog(color,near,far);
				//scene.fog=new THREE.Fog(0xFFFFFF,.1,100);
				//THREE.Fog(color,density);
				scene.fog = new THREE.FogExp2(0xFFFFFF, .01);
			}
			{//Feb.12 - scene.overrideMaterial property	
				scene.overrideMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF, wireframe: true, wireframeLinewidth: 1 });

			}

			// render the scene
			renderScene2();
			function initStats() {
				var stats = new Stats();
				stats.setMode(0); // 0 => fps, 1 => ms / frame
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.left = '0px';
				stats.domElement.style.top = '0px';
				document.getElementById("stats-output").appendChild(stats.domElement);
				return stats;
			}
			function Deg2Rad(angle_in_degrees) {
				var angle_in_radians = (angle_in_degrees || 0) * Math.PI / 180;
				return angle_in_radians;
			}
			function createSphere(r, nw, nh, col, wf, px, py, pz, rx, ry, rz, sx, sy, sz) {
				//Add a sphere
				//THREE.SphereGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)
				//rotations are in degrees
				var sphereGeometry = new THREE.SphereGeometry(r || 1, nw || 3, nh || 3);
				var sphereMaterial = new THREE.MeshBasicMaterial({ color: col || 0xFFFFFF, wireframe: wf || false });
				var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

				sphere.position.x = px || 0;
				sphere.position.y = py || 0;
				sphere.position.z = pz || 0;

				sphere.rotation.x = Deg2Rad(rx) || 0;
				sphere.rotation.y = Deg2Rad(ry) || 0;
				sphere.rotation.z = Deg2Rad(rz) || 0;


				sphere.scale.x = sx || 1;
				sphere.scale.y = sy || 1; //30 deg
				sphere.scale.z = sz || 1; //30 deg
				return sphere;

			}
			function createCube(dx, dy, dz, col, wf, px, py, pz, rx, ry, rz, sx, sy, sz) {
				//Add a Cube
				//THREE.SphereGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)
				//rotations are in degrees
				var cubeGeometry = new THREE.BoxGeometry(dx || 1, dy || 1, dz || 1);
				var cubeMaterial = new THREE.MeshBasicMaterial({ color: col || 0xFFFFFF, wireframe: wf || false });
				var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

				cube.position.x = px || 0;
				cube.position.y = py || 0;
				cube.position.z = pz || 0;

				cube.rotation.x = Deg2Rad(rx) || 0;
				cube.rotation.y = Deg2Rad(ry) || 0;
				cube.rotation.z = Deg2Rad(rz) || 0;


				cube.scale.x = sx || 1;
				cube.scale.y = sy || 1; //30 deg
				cube.scale.z = sz || 1; //30 deg
				return cube;

			}
			function createCubeMLM(dx, dy, dz, col, wf, px, py, pz, rx, ry, rz, sx, sy, sz) {
				//Add a Cube with MeshLambertMaterial
				//THREE.SphereGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)
				//rotations are in degrees
				var cubeGeometry = new THREE.BoxGeometry(dx || 1, dy || 1, dz || 1);
				var cubeMaterial = new THREE.MeshLambertMaterial({ color: col || 0xFFFFFF, wireframe: wf || false });
				var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

				cube.position.x = px || 0;
				cube.position.y = py || 0;
				cube.position.z = pz || 0;

				cube.rotation.x = Deg2Rad(rx) || 0;
				cube.rotation.y = Deg2Rad(ry) || 0;
				cube.rotation.z = Deg2Rad(rz) || 0;


				cube.scale.x = sx || 1;
				cube.scale.y = sy || 1; //30 deg
				cube.scale.z = sz || 1; //30 deg
				return cube;

			}
			function renderScene() {
				//wire up stats
				stats.update();

				var x = camera.position.x;
				var y = camera.position.y;
				var z = camera.position.z;
				//var r=Math.sqrt(x*x+y*y);
				r = 2;
				step += 0.1;
				camera.position.set(x + r * Math.sin(step), y, z + r * Math.cos(step));
				camera.lookAt(scene.position);

				//green_cube.castShadow=true;
				//scene.add(green_cube);

				requestAnimationFrame(renderScene);
				renderer.render(scene, camera);
			}
			function renderScene2() {
				//wire up stats
				stats.update();

				var x = spotLight.position.x;
				var y = spotLight.position.y;
				var z = spotLight.position.z;
				r = 2;
				step += 0.1;
				//spotLight.position.set(x+r*Math.sin(step),y,z+r*Math.cos(step));

				//Feb.05 - Using dat.GUI Step 5 - use controls 
				//scene.remove(green_cube);
				green_cube.scale.x = controls.dx / 10;
				green_cube.scale.y = controls.dy / 30;
				green_cube.scale.z = controls.dz / 10;

				green_cube.position.set(controls.px, controls.py, controls.pz);





				requestAnimationFrame(renderScene2);
				renderer.render(scene, camera);
			}

		}
		window.onload = init

	</script>
</body>

</html>